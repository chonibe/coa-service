import { NextResponse } from "next/server"
import { supabase } from "@/lib/supabase"

interface OrderLineItem {
  id: string
  name: string
  product_id: string
  vendor_id: string
  image_url: string
  nfc_claimed_at?: string
  description?: string
  quantity: number
  price?: number
  img_url?: string
  nfc_tag_id: string | null
  certificate_url: string
  certificate_token?: string
  edition_number?: number | null
  edition_total?: number | null
  vendor_name?: string
  status?: string
}

interface Order {
  id: string
  order_line_items_v2: OrderLineItem[]
}

export async function GET(
  request: Request,
  { params }: { params: { customerId: string } }
) {
  try {
    if (!supabase) {
      throw new Error("Database connection not available")
    }

    // Fetch line items
    const { data: lineItems, error: lineItemsError } = await supabase
      .from("orders")
      .select(`
        id,
        order_line_items_v2 (
          id,
          name,
          product_id,
          vendor_id,
          image_url,
          nfc_claimed_at,
          description,
          quantity,
          price,
          img_url,
          nfc_tag_id,
          certificate_url,
          certificate_token,
          edition_number,
          edition_total,
          vendor_name,
          status
        )
      `)
      .eq("customer_id", params.customerId)

    if (lineItemsError) {
      throw lineItemsError
    }

    // Transform the nested data structure
    const flattenedLineItems = (lineItems as Order[] | null)?.flatMap(order => 
      order.order_line_items_v2.map((item: OrderLineItem) => ({
        ...item,
        order_id: order.id
      }))
    ) || []

    // Fetch rewards data
    const { data: rewardsData, error: rewardsError } = await supabase
      .from("customer_rewards")
      .select("*")
      .eq("customer_id", params.customerId)
      .single()

    if (rewardsError && rewardsError.code !== "PGRST116") {
      throw rewardsError
    }

    // Fetch recent reward events
    const { data: rewardEvents, error: eventsError } = await supabase
      .from("reward_events")
      .select("*")
      .eq("customer_id", params.customerId)
      .order("created_at", { ascending: false })
      .limit(5)

    if (eventsError) {
      throw eventsError
    }

    // Get current tier benefits
    const { data: currentTier, error: currentTierError } = await supabase
      .from("reward_tiers")
      .select("*")
      .eq("name", rewardsData?.level || "bronze")
      .single()

    if (currentTierError) {
      throw currentTierError
    }

    // Get next tier if exists
    const { data: nextTier, error: nextTierError } = await supabase
      .from("reward_tiers")
      .select("*")
      .gt("required_points", rewardsData?.points || 0)
      .order("required_points", { ascending: true })
      .limit(1)
      .single()

    if (nextTierError && nextTierError.code !== "PGRST116") {
      throw nextTierError
    }

    return NextResponse.json({
      success: true,
      lineItems: flattenedLineItems,
      rewards: {
        ...rewardsData,
        currentTier,
        nextTier,
        recentEvents: rewardEvents
      }
    })
  } catch (error: any) {
    console.error("Dashboard API Error:", error)
    return NextResponse.json(
      {
        success: false,
        message: error.message || "An unexpected error occurred"
      },
      { status: 500 }
    )
  }
} 